# Copyright 2022 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Test for IPU Keras single IPU model."""

import os
import tempfile
import numpy as np

from absl.testing import parameterized
import tensorflow.compat.v2 as tf

from tensorflow.python.ipu.config import IPUConfig
from tensorflow.python.ipu import test_utils as tu
from tensorflow.python import ipu

import keras
from keras import testing_utils


class TestServingExportBase(tf.test.TestCase, parameterized.TestCase):
  def setUp(self):
    super().setUp()
    self.use_ipus(1)

  def use_ipus(self, num):
    cfg = IPUConfig()
    cfg.auto_select_ipus = num
    tu.add_hw_ci_connection_options(cfg)
    cfg.configure_ipu_system()

  def _load_and_run(self, path, inputs):
    imported = tf.saved_model.load(path)
    loaded = imported.signatures[
        tf.saved_model.DEFAULT_SERVING_SIGNATURE_DEF_KEY]
    output_name = next(iter(loaded.structured_outputs.values())).name
    input_names = [inp.name.split(':')[0] for inp in loaded.inputs]

    if isinstance(inputs, list):
      # Handle cases with input names generated by Keras.
      input_names = [name for name in input_names if "input_" in name]
      assert len(input_names) == len(inputs)
      input_names.sort(key=lambda name: int(name.split("_")[1]))
      inputs = {input_names[i]: inputs[i] for i in range(len(inputs))}
    elif not isinstance(inputs, dict):
      inputs = {input_names[0]: inputs}

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      result = strategy.run(loaded, kwargs=inputs)

    return result[output_name]


class ExportForServingTest(TestServingExportBase):
  @tu.test_uses_ipus(num_ipus=1, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_sequential_one_input(self):
    input_shape = (1, 3, 1)

    strategy = ipu.ipu_strategy.IPUStrategyV1()
    with strategy.scope():
      model = keras.Sequential()
      model.add(
          keras.layers.Conv1D(
              filters=2,
              kernel_size=2,
              kernel_initializer=keras.initializers.Constant(value=3)))
      model.add(keras.layers.Activation('relu'))

      model.build(input_shape)
      model.compile(steps_per_execution=16)

    input_data = np.array([[[-1.0], [2.0], [-3.0]]], dtype=np.float32)
    with tempfile.TemporaryDirectory() as tmp_folder:
      runtime_func = ipu.serving.export_keras(model, tmp_folder)
      # Test runtime function
      with strategy.scope():
        runtime_result = strategy.run(runtime_func,
                                      args=(tf.constant(input_data),))
        runtime_result = np.array(runtime_result[0])
      ref_result = np.array([[[3.0, 3.0], [0.0, 0.0]]], dtype=np.float32)
      self.assertTrue(np.array_equal(runtime_result, ref_result))

      # Test loaded model
      loaded_result = self._load_and_run(tmp_folder, input_data)
      loaded_result = np.array(loaded_result)
      self.assertTrue(np.array_equal(loaded_result, ref_result))

  @tu.test_uses_ipus(num_ipus=1, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_functional_two_inputs(self):
    bs = tf.constant(1, dtype=tf.int32)
    input1_shape = (bs, 3, 1)
    input2_shape = (bs, 1)

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      input1 = keras.layers.Input(shape=input1_shape[1:],
                                  name='x1',
                                  batch_size=bs)
      input2 = keras.layers.Input(shape=input2_shape[1:],
                                  name='x2',
                                  batch_size=bs)
      x = keras.layers.Conv1D(
          filters=2,
          kernel_size=2,
          kernel_initializer=keras.initializers.Constant(value=3))(input1)
      x = keras.layers.Add()([x, input2])
      x = keras.layers.Activation('relu')(x)
      model = keras.Model(inputs=[input1, input2], outputs=x)

      model.build([input1_shape, input2_shape])
      model.compile(steps_per_execution=16)

    input1 = np.array([[[-1.0], [2.0], [-3.0]]], dtype=np.float32)
    input2 = np.array([[2.0]], dtype=np.float32)

    with tempfile.TemporaryDirectory() as tmp_folder:
      ipu.serving.export_keras(model, tmp_folder)
      result = self._load_and_run(tmp_folder, {'x1': input1, 'x2': input2})
      result = np.array(result)
      ref_result = np.array([[[5.0, 5.0], [0.0, 0.0]]], dtype=np.float32)
      self.assertTrue(np.array_equal(result, ref_result))

  @tu.test_uses_ipus(num_ipus=1, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_subclass_model_two_inputs(self):
    bs = tf.constant(2, dtype=tf.int32)
    input1_shape = (bs, 3, 1)
    input2_shape = (bs, 1)

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():

      class SimpleModel(keras.Model):  # pylint: disable=abstract-method
        def __init__(self):
          super().__init__()
          self.conv = keras.layers.Conv1D(
              filters=2,
              kernel_size=2,
              kernel_initializer=keras.initializers.Constant(value=3))
          self.relu = keras.layers.Activation('relu')
          self.add = keras.layers.Add()

        def call(self, inputs):  # pylint: disable=arguments-differ
          input1, input2 = inputs[0], inputs[1]
          x = self.conv(input1)
          x = self.add([x, input2])
          x = self.relu(x)
          return x

      model = SimpleModel()
      model.build([input1_shape, input2_shape])
      model.compile(steps_per_execution=16)

      input1 = np.array([[[-1.0], [2.0], [-3.0]], [[-0.5], [0.0], [-2.0]]],
                        dtype=np.float32)
      input2 = np.array([[2.0], [4.0]], dtype=np.float32)

    with tempfile.TemporaryDirectory() as tmp_folder:
      ipu.serving.export_keras(model, tmp_folder)
      result = self._load_and_run(tmp_folder, {
          'input_1': input1,
          'input_2': input2
      })
      result = np.array(result)
      ref_result = np.array(
          [[[5.0, 5.0], [0.0, 0.0]], [[2.5, 2.5], [0.0, 0.0]]],
          dtype=np.float32)
      self.assertTrue(np.array_equal(result, ref_result))

  @tu.test_uses_ipus(num_ipus=1, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_without_ipu_strategy(self):
    input_shape = (1,)
    model = keras.Sequential()
    model.add(keras.layers.Activation('relu'))
    model.build(input_shape)
    model.compile(steps_per_execution=16)

    with tempfile.TemporaryDirectory() as tmp_folder:
      with self.assertRaisesRegex(ValueError, "IPU strategy"):
        ipu.serving.export_keras(model, tmp_folder)

  @tu.test_uses_ipus(num_ipus=1, allow_ipu_model=True)
  @testing_utils.run_v2_only
  def test_export_keras_fails_for_non_empty_dir(self):
    input_shape = (1,)
    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      model = keras.models.Sequential()
      model.add(keras.layers.Activation('relu'))
      model.build(input_shape)
      model.compile(steps_per_execution=16)

    with tempfile.TemporaryDirectory() as tmp_folder:
      open(os.path.join(tmp_folder, 'dummy_file'), 'w').close()
      with self.assertRaisesRegex(ValueError, "is not empty"):
        ipu.serving.export_keras(model, tmp_folder)
      with self.assertRaisesRegex(ValueError, "is not empty"):
        model.export_for_ipu_serving(tmp_folder)

  @tu.test_uses_ipus(num_ipus=2, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_pipelined_sequential_one_input(self):
    self.use_ipus(2)
    bs = tf.constant(2, dtype=tf.int32)
    input_shape = (bs, 3, 1)

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      model = keras.models.Sequential()
      model.add(
          keras.layers.Conv1D(
              filters=2,
              kernel_size=2,
              kernel_initializer=keras.initializers.Constant(value=3)))
      model.add(keras.layers.Activation('relu'))

      model.set_pipeline_stage_assignment([0, 1])
      model.set_pipelining_options(device_mapping=[0, 1])
      model.build(input_shape)
      model.compile(steps_per_execution=16)

    input1 = np.array([[[-1.0], [2.0], [-3.0]], [[-0.5], [0.0], [-2.0]]],
                      dtype=np.float32)
    with tempfile.TemporaryDirectory() as tmp_folder:
      ipu.serving.export_keras(model, tmp_folder)
      result = self._load_and_run(tmp_folder, input1)
      result = np.array(result)
      ref_result = np.array(
          [[[3.0, 3.0], [0.0, 0.0]], [[0.0, 0.0], [0.0, 0.0]]],
          dtype=np.float32)
      self.assertTrue(np.array_equal(result, ref_result))

  @tu.test_uses_ipus(num_ipus=2, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_pipelined_functional_two_inputs(self):
    self.use_ipus(2)
    bs = tf.constant(2, dtype=tf.int32)
    input1_shape = (bs, 3, 1)
    input2_shape = (bs, 1)

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      input1 = keras.layers.Input(shape=input1_shape[1:],
                                  name='x1',
                                  batch_size=bs)
      input2 = keras.layers.Input(shape=input2_shape[1:],
                                  name='x2',
                                  batch_size=bs)

      with keras.ipu.PipelineStage(0):
        x = keras.layers.Conv1D(
            filters=2,
            kernel_size=2,
            kernel_initializer=keras.initializers.Constant(value=3))(input1)

      with keras.ipu.PipelineStage(1):
        x = keras.layers.Add()([x, input2])
        x = keras.layers.Activation('relu')(x)

      model = keras.Model(inputs=(input1, input2), outputs=x)

      model.set_pipelining_options(device_mapping=[0, 1])

      model.build((input1_shape, input2_shape))
      model.compile(steps_per_execution=16)

    input1 = np.array([[[-1.0], [2.0], [-3.0]], [[-0.5], [0.0], [-2.0]]],
                      dtype=np.float32)
    input2 = np.array([[2.0], [4.0]], dtype=np.float32)
    with tempfile.TemporaryDirectory() as tmp_folder:
      ipu.serving.export_keras(model, tmp_folder)
      result = self._load_and_run(tmp_folder, {'x1': input1, 'x2': input2})
      result = np.array(result)
      ref_result = np.array(
          [[[5.0, 5.0], [0.0, 0.0]], [[2.5, 2.5], [0.0, 0.0]]],
          dtype=np.float32)
      self.assertTrue(np.array_equal(result, ref_result))

  @tu.test_uses_ipus(num_ipus=2, allow_ipu_model=False)
  @testing_utils.run_v2_only
  def test_export_keras_pipelined_subclass_model_two_inputs(self):
    self.use_ipus(2)
    bs = tf.constant(2, dtype=tf.int32)
    input1_shape = (bs, 3, 1)
    input2_shape = (bs, 1)

    class SimpleModel(keras.Model):  # pylint: disable=abstract-method
      def __init__(self):
        super().__init__()
        self.conv = keras.layers.Conv1D(
            filters=2,
            kernel_size=2,
            kernel_initializer=keras.initializers.Constant(value=3))
        self.relu = keras.layers.Activation('relu')
        self.add = keras.layers.Add()

      def call(self, inputs):  # pylint: disable=arguments-differ
        with keras.ipu.PipelineStage(0):
          x, y = inputs[0], inputs[1]
          x = self.conv(x)

        with keras.ipu.PipelineStage(1):
          x = self.add([x, y])
          x = self.relu(x)
        return x

    strategy = ipu.ipu_strategy.IPUStrategy()
    with strategy.scope():
      model = SimpleModel()
      model.build([input1_shape, input2_shape])
      model.set_pipelining_options(device_mapping=[0, 1])
      model.compile(steps_per_execution=16)

    input1 = np.array([[[-1.0], [2.0], [-3.0]], [[-0.5], [0.0], [-2.0]]],
                      dtype=np.float32)
    input2 = np.array([[2.0], [4.0]], dtype=np.float32)
    with tempfile.TemporaryDirectory() as tmp_folder:
      ipu.serving.export_keras(model, tmp_folder)
      result = self._load_and_run(tmp_folder, [input1, input2])
      result = np.array(result)
      ref_result = np.array(
          [[[5.0, 5.0], [0.0, 0.0]], [[2.5, 2.5], [0.0, 0.0]]],
          dtype=np.float32)
      self.assertTrue(np.array_equal(result, ref_result))


if __name__ == '__main__':
  tf.test.main()
